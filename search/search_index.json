{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>This is my python knowledge. See Project Setup and Software Requirements to use this repository. Go to Chapters to access the actual content.</p>"},{"location":"project_setup/","title":"Project Setup","text":"<ul> <li>make sure all software requirements are met beforehand</li> <li>create new pip environment</li> </ul> <p><pre><code>pipenv shell\n</code></pre> - installing python packages is handled via pipenv</p> <pre><code>pipenv install [package name...]\n</code></pre>"},{"location":"software_requirements/","title":"Software Requirements","text":""},{"location":"software_requirements/#software","title":"Software","text":"<ul> <li>Visual Studio Code</li> <li>git</li> <li>python 3.11 64 bit</li> <li>pip<ul> <li>py -m ensurepip --upgrade</li> <li>pip install pipenv</li> </ul> </li> </ul>"},{"location":"software_requirements/#optional-visual-studio-code-extensions","title":"(optional) Visual Studio Code Extensions","text":"<ul> <li>Markdown Preview Enhanced</li> <li>Github Copilot</li> <li>Python (v2023.18.0, because the newer version has some weird bugs..)</li> <li>better Comments</li> <li>autoDocstring</li> <li>Rainbow CSV</li> </ul>"},{"location":"chapters/functional_programming/","title":"Functional Programming","text":"<p>This chapter is based on the YouTube series Functional Programming in Python by Real Python and aims to give a quickoverview to beginners and reference for advanced users.</p>"},{"location":"chapters/functional_programming/#immutable-data-structures","title":"Immutable Data Structures","text":"<p>The credo of functional programming is \"There shall be no state!\". In that spirit a function should not have an inner state or should depend on some sort of state at all. Instead a given function should return the same output every time it is given the same input. It is often useful to therefor protect data (that is used in pipelines of functional code) from changes. Datatypes that cannot be changed after initialization are called immutable.</p> <p>Python has several basic structures and patterns that can be used. The following table offers a sort of translation of common types or patterns and their immutable counterparts.</p> Structure/Pattern Immutable Counterpart List tuple Data Class namedtuple for loop recursive function"},{"location":"chapters/functional_programming/#named-tuple","title":"Named Tuple","text":"<p><pre><code>\"\"\" This example creates a namedtuple Person to store information about\n    a person. The namedtuple is immutable, so it cannot be changed once\n    it is created. The attributes are first_name, last_name, and age.\n\"\"\"\nfrom pprint import pprint\nfrom collections import namedtuple\n\nPerson = namedtuple(\"Person\", [\n    \"first_name\",\n    \"last_name\",\n    \"age\"\n])\n\nperson1 = Person(\"John\", \"Doe\", 30)\nperson2 = Person(\"Jane\", \"Doe\", 25)\n\npprint(person1)\nprint()\npprint(person2)\nprint()\nperson1.age = 31\n</code></pre> Output: <pre><code>Person(first_name='John', last_name='Doe', age=30)\n\nPerson(first_name='Jane', last_name='Doe', age=25)\n\nTraceback (most recent call last):\n  ...\n    person1.age = 31\n    ^^^^^^^^^^^\nAttributeError: can't set attribute\n</code></pre></p>"},{"location":"chapters/functional_programming/#tuple","title":"Tuple","text":"<p><pre><code>from pprint import pprint\nfrom collections import namedtuple\n\nPerson = namedtuple(\"Person\", [\n    \"first_name\",\n    \"last_name\",\n    \"age\"\n])\n\nmy_very_mutable_list = [\n    Person(\"John\", \"Doe\", 30),\n    Person(\"Jane\", \"Doe\", 25),\n    Person(\"Mister\", \"Roboto\", 1000)]\n\n# this transforms a list into a tuple\npprint(tuple(my_very_mutable_list))\n\n# but the list is still mutable...\ndel my_very_mutable_list[0]\nprint()\npprint(tuple(my_very_mutable_list))\n\n# but the array is not even needed. just create the tuple directly with (...)!\nmy_very_immutable_tuple = (\n    Person(\"John\", \"Doe\", 30),\n    Person(\"Jane\", \"Doe\", 25),\n    Person(\"Mister\", \"Roboto\", 1000)\n)\nprint()\npprint(my_very_immutable_tuple)\n\n# and now it is immutable\nprint()\ndel my_very_immutable_tuple[0]\n</code></pre> Output: <pre><code>(Person(first_name='John', last_name='Doe', age=30),\n Person(first_name='Jane', last_name='Doe', age=25),\n Person(first_name='Mister', last_name='Roboto', age=1000))\n\n(Person(first_name='Jane', last_name='Doe', age=25),\n Person(first_name='Mister', last_name='Roboto', age=1000))\n\n(Person(first_name='John', last_name='Doe', age=30),\n Person(first_name='Jane', last_name='Doe', age=25),\n Person(first_name='Mister', last_name='Roboto', age=1000))\n\nTraceback (most recent call last):\n  ...\n    del my_very_immutable_tuple[0]\n        ~~~~~~~~~~~~~~~~~~~~~~~^^^\nTypeError: 'tuple' object doesn't support item deletion\n</code></pre></p>"},{"location":"chapters/functional_programming/#recursive-function","title":"Recursive Function","text":"<p><pre><code>from pprint import pprint\nfrom collections import namedtuple\n\nPerson = namedtuple(\"Person\", [\n    \"first_name\",\n    \"last_name\",\n    \"age\"\n])\n\npersons = (\n    Person(\"John\", \"Doe\", 30),\n    Person(\"Jane\", \"Doe\", 25),\n    Person(\"Mister\", \"Roboto\", 1000)\n)\n\n# how a for loop might iterative over my_very_immutable_tuple\nprint(\"---------------------------------------------------------------\")\nfor i in range(0, len(persons)):\n    pprint(persons[i])\n\n# but this is of course not in the spirit of functional programming\n# since i is a local variable that represents the state of the loop\n# instead use a resursive function\n\n\ndef print_tuple(iterable, index=0):\n    # this is a recursion anchor (and also a guard clause, so double-cool!)\n    if index &lt; 0 or index &gt;= len(iterable):\n        return\n    pprint(iterable[index])\n    print_tuple(iterable, index + 1)\n\n\nprint(\"---------------------------------------------------------------\")\n# now call the recursive function\nprint_tuple(persons)\n\n# now to take this a step further: the action taken in print_tuple is to use pprint\n# this can be abstracted out into a function that takes a function as an argument\n\n\ndef foreach_element(iterable, consumer, index=0):\n    if index &lt; 0 or index &gt;= len(iterable):\n        return\n    consumer(iterable[index])\n    foreach_element(iterable, consumer, index + 1)\n\n\nprint(\"---------------------------------------------------------------\")\n# also prints the tuple\nforeach_element(persons, pprint)\n\nprint(\"---------------------------------------------------------------\")\n# now lets do something else with the elements of the tuple by passing a different function\nforeach_element(persons, lambda person: print(\n    \"first name is\", person.first_name))\nprint(\"---------------------------------------------------------------\")\n</code></pre> Output: <pre><code>---------------------------------------------------------------\nPerson(first_name='John', last_name='Doe', age=30)\nPerson(first_name='Jane', last_name='Doe', age=25)\nPerson(first_name='Mister', last_name='Roboto', age=1000)\n---------------------------------------------------------------\nPerson(first_name='John', last_name='Doe', age=30)\nPerson(first_name='Jane', last_name='Doe', age=25)\nPerson(first_name='Mister', last_name='Roboto', age=1000)\n---------------------------------------------------------------\nPerson(first_name='John', last_name='Doe', age=30)\nPerson(first_name='Jane', last_name='Doe', age=25)\nPerson(first_name='Mister', last_name='Roboto', age=1000)\n---------------------------------------------------------------\nfirst name is John\nfirst name is Jane\nfirst name is Mister\n---------------------------------------------------------------\n</code></pre></p>"}]}